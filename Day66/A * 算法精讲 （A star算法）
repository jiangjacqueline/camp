A * 算法精讲 （A star算法）
题目描述

在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。

骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。
https://file1.kamacoder.com/i/algo/20240626104833.png
棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界）

输入描述

第一行包含一个整数 n，表示测试用例的数量。

接下来的 n 行，每行包含四个整数 a1, a2, b1, b2，分别表示骑士的起始位置 (a1, a2) 和目标位置 (b1, b2)。

输出描述

输出共 n 行，每行输出一个整数，表示骑士从起点到目标点的最短路径长度。

输入示例

6
5 2 5 4
1 1 2 2
1 1 8 8
1 1 8 7
2 1 3 3
4 6 4 6
输出示例

2
4
6
5
1
0

import java.util.*;

public class Main {
    static int[][] moves = new int[1001][1001];
    static int[][] dir = {
        {-2, -1}, {-2, 1}, {-1, 2}, {1, 2},
        {2, 1}, {2, -1}, {1, -2}, {-1, -2}
    };
    static int b1, b2;

    static class Knight implements Comparable<Knight> {
        int x, y;
        int g, h, f;

        @Override
        public int compareTo(Knight k) {
            // reverse order (smallest f first)
            return Integer.compare(this.f, k.f);
        }
    }

    static int heuristic(Knight k) {
        // Euclidean distance squared (no sqrt for efficiency)
        return (k.x - b1) * (k.x - b1) + (k.y - b2) * (k.y - b2);
    }

    static void astar(Knight start) {
        PriorityQueue<Knight> pq = new PriorityQueue<>();
        pq.offer(start);

        while (!pq.isEmpty()) {
            Knight cur = pq.poll();
            if (cur.x == b1 && cur.y == b2)
                break;

            for (int i = 0; i < 8; i++) {
                int nx = cur.x + dir[i][0];
                int ny = cur.y + dir[i][1];

                if (nx < 1 || nx > 1000 || ny < 1 || ny > 1000)
                    continue;

                if (moves[nx][ny] == 0) {
                    moves[nx][ny] = moves[cur.x][cur.y] + 1;

                    Knight next = new Knight();
                    next.x = nx;
                    next.y = ny;
                    next.g = cur.g + 5; // Knight moves cost = 5 (1^2 + 2^2)
                    next.h = heuristic(next);
                    next.f = next.g + next.h;

                    pq.offer(next);
                }
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        while (n-- > 0) {
            int a1 = sc.nextInt();
            int a2 = sc.nextInt();
            b1 = sc.nextInt();
            b2 = sc.nextInt();

            for (int i = 0; i <= 1000; i++) {
                Arrays.fill(moves[i], 0);
            }

            Knight start = new Knight();
            start.x = a1;
            start.y = a2;
            start.g = 0;
            start.h = heuristic(start);
            start.f = start.g + start.h;

            astar(start);
            System.out.println(moves[b1][b2]);
        }

        sc.close();
    }
}
