题目藐视
在一个城市区域内，被划分成了n * m个连续的区块，每个区块都拥有不同的权值，代表着其土地价值。目前，有两家开发公司，A 公司和 B 公司，希望购买这个城市区域的土地。 
现在，需要将这个城市区域的所有区块分配给 A 公司和 B 公司。
然而，由于城市规划的限制，只允许将区域按横向或纵向划分成两个子区域，而且每个子区域都必须包含一个或多个区块。 为了确保公平竞争，你需要找到一种分配方式，使得 A 公司和 B 公司各自的子区域内的土地总价值之差最小。 
注意：区块不可再分。

输入描述
第一行输入两个正整数，代表 n 和 m。 
接下来的 n 行，每行输出 m 个正整数。

输出描述
请输出一个整数，代表两个子区域内土地总价值之间的最小差距。

输入示例
3 3
1 2 3
2 1 3
1 2 3

输出示例
0

提示信息
如果将区域按照如下方式划分：

1 2 | 3
2 1 | 3
1 2 | 3 

两个子区域内土地总价值之间的最小差距可以达到 0。

数据范围：

1 <= n, m <= 100；
n 和 m 不同时为 1。

import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // 读取输入
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        int[][] grid = new int[n][m];
        int totalSum = 0;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                grid[i][j] = scanner.nextInt();
                totalSum += grid[i][j];
            }
        }

        // 构建二维前缀和
        int[][] prefixSum = new int[n + 1][m + 1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                prefixSum[i][j] = grid[i - 1][j - 1] 
                                + prefixSum[i - 1][j] 
                                + prefixSum[i][j - 1] 
                                - prefixSum[i - 1][j - 1];
            }
        }

        int minDiff = Integer.MAX_VALUE;

        // 横向划分
        for (int row = 1; row < n; row++) {
            int sumTop = getRegionSum(prefixSum, 1, 1, row, m);
            int sumBottom = totalSum - sumTop;
            minDiff = Math.min(minDiff, Math.abs(sumTop - sumBottom));
        }

        // 纵向划分
        for (int col = 1; col < m; col++) {
            int sumLeft = getRegionSum(prefixSum, 1, 1, n, col);
            int sumRight = totalSum - sumLeft;
            minDiff = Math.min(minDiff, Math.abs(sumLeft - sumRight));
        }

        System.out.println(minDiff);
    }

    // 获取从(x1, y1)到(x2, y2)的矩阵和（1-based index）
    private static int getRegionSum(int[][] prefixSum, int x1, int y1, int x2, int y2) {
        return prefixSum[x2][y2] 
             - prefixSum[x1 - 1][y2] 
             - prefixSum[x2][y1 - 1] 
             + prefixSum[x1 - 1][y1 - 1];
    }
}
